import { describe, expect, test } from "bun:test"
import { sin, cos, tan, acos, asin, atan, atan2 } from "../tigonometry"

describe("math", () => {
	test("sin", () => {
		expect(sin(0)).toBe(0)
		expect(sin(Math.PI / 2)).toBe(1)
		expect(sin(Math.PI)).toBe(1.2246467991473532e-16)
		expect(sin((3 * Math.PI) / 2)).toBe(-1)
		expect(sin(2 * Math.PI)).toBe(-2.4492935982947064e-16)
		expect(sin(NaN)).toBe(NaN)
		expect(sin(Infinity)).toBe(NaN)
		expect(sin(-Infinity)).toBe(NaN)
	})
	test("cos", () => {
		expect(cos(0)).toBe(1)
		expect(cos(Math.PI / 2)).toBe(6.123233995736766e-17)
		expect(cos(Math.PI)).toBe(-1)
		expect(cos((3 * Math.PI) / 2)).toBe(-1.8369701987210297e-16)
		expect(cos(2 * Math.PI)).toBe(1)
		expect(cos(NaN)).toBe(NaN)
		expect(cos(Infinity)).toBe(NaN)
		expect(cos(-Infinity)).toBe(NaN)
	})
	test("tan", () => {
		expect(tan(0)).toBe(0)
		expect(tan(1)).toBe(1.5574077246549023)
		expect(tan(2 / Math.PI)).toBe(0.7393029504866041)
		expect(tan(Math.PI / 2)).toBe(16331239353195370)
		expect(tan(Math.PI / 4)).toBe(0.9999999999999999)
		expect(tan(Math.PI)).toBe(-1.2246467991473532e-16)
		expect(tan((3 * Math.PI) / 4)).toBe(-1.0000000000000002)
		expect(tan(NaN)).toBe(NaN)
		expect(tan(Infinity)).toBe(NaN)
		expect(tan(-Infinity)).toBe(NaN)
	})
	test("asin", () => {
		expect(asin(0)).toBe(0)
		expect(asin(1)).toBe(Math.PI / 2)
		expect(asin(-1)).toBe(-Math.PI / 2)
		expect(asin(0.5)).toBe(0.5235987755982989)
		expect(asin(-0.5)).toBe(-0.5235987755982989)
		expect(asin(2 / Math.PI)).toBe(0.69010709137454)
		expect(asin(2)).toBe(NaN)
		expect(asin(-2)).toBe(NaN)
		expect(asin(NaN)).toBe(NaN)
		expect(asin(Infinity)).toBe(NaN)
		expect(asin(-Infinity)).toBe(NaN)
	})
	test("acos", () => {
		expect(acos(0)).toBe(Math.PI / 2)
		expect(acos(1)).toBe(0)
		expect(acos(-1)).toBe(Math.PI)
		expect(acos(0.5)).toBe(1.0471975511965979)
		expect(acos(-0.5)).toBe(2.0943951023931957)
		expect(acos(2 / Math.PI)).toBe(0.8806892354203566)
		expect(acos(2)).toBe(NaN)
		expect(acos(-2)).toBe(NaN)
		expect(acos(NaN)).toBe(NaN)
		expect(acos(Infinity)).toBe(NaN)
		expect(acos(-Infinity)).toBe(NaN)
	})
	test("atan", () => {
		expect(atan(0)).toBe(0)
		expect(atan(1)).toBe(Math.PI / 4)
		expect(atan(-1)).toBe(-Math.PI / 4)
		expect(atan(Math.sqrt(3))).toBe(Math.PI / 3)
		expect(atan(-Math.sqrt(3))).toBe(-Math.PI / 3)
		expect(atan(NaN)).toBe(NaN)
		expect(atan(Infinity)).toBe(Math.PI / 2)
		expect(atan(-Infinity)).toBe(-Math.PI / 2)
	})
	test("atan2", () => {
		expect(atan2(0, 1)).toBe(0)
		expect(atan2(1, 0)).toBe(Math.PI / 2)
		expect(atan2(0, -1)).toBe(Math.PI)
		expect(atan2(-1, 0)).toBe(-Math.PI / 2)
		expect(atan2(1, 1)).toBe(Math.PI / 4)
		expect(atan2(-1, -1)).toBe((-3 * Math.PI) / 4)
		expect(atan2(1, -1)).toBe((3 * Math.PI) / 4)
		expect(atan2(-1, 1)).toBe(-Math.PI / 4)
		expect(atan2(0, 0)).toBe(0)
		expect(atan2(Math.PI, Math.PI)).toBe(Math.PI / 4)
		expect(atan2(Math.PI, -Math.PI)).toBe((3 * Math.PI) / 4)
		expect(atan2(NaN, 1)).toBe(NaN)
		expect(atan2(1, NaN)).toBe(NaN)
		expect(atan2(NaN, NaN)).toBe(NaN)
		expect(atan2(Infinity, 1)).toBe(Math.PI / 2)
		expect(atan2(-Infinity, 1)).toBe(-Math.PI / 2)
		expect(atan2(1, Infinity)).toBe(0)
		expect(atan2(1, -Infinity)).toBe(Math.PI)
		expect(atan2(Infinity, Infinity)).toBe(Math.PI / 4)
		expect(atan2(-Infinity, -Infinity)).toBe((-3 * Math.PI) / 4)
		expect(atan2(Infinity, -Infinity)).toBe((3 * Math.PI) / 4)
		expect(atan2(-Infinity, Infinity)).toBe(-Math.PI / 4)
	})
})
